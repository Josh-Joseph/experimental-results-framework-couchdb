{
   "_id": "_design/plots",
   "_rev": "29-d8247ef20d56adba78e9d7343ccbdaa0",
   "language": "javascript",
   "views": {
       "means_by_code_and_parameters": {
           "map": "function(doc) {\n  emit([doc.code.version, doc.computation.parameters], doc.computation.result.mean);\n}",
           "reduce": "function( keys, values, rereduce ) {\n    return sum( values ) / values.length;\n}"
       },
       "histogram_pid": {
           "map": "function(doc) {\n  emit([doc.code.version, doc.computation.parameters], doc.computation.result.mean);\n}",
           "reduce": "function( keys, values, rereduce ) {\n\n  function add_to_bin( v, bin ) {\n    if( !bin.min_value || v < bin.min_value ) {\n      bin.min_value = v; \n    } else if( !bin.max_value || v > bin.max_value ) {\n      bin.max_value = v;\n    }\n    bin.count += 1;\n    bin.values.push( v );\n  };\n\n  function is_inside_bin( v, bin ) {\n    return ( v >= bin.min_limit && v < bin.max_limit );\n  };\n\n\n  function split_bin( bin ) {\n    //log( \"splitting bin: \" + JSON.stringify(bin) );\n    var mid_point = bin.min_limit + (bin.max_limit - bin.min_limit) / 2.0;\n    var new_bin = {\n      count: 0,\n      min_limit: mid_point,\n      max_limit: bin.max_limit,\n      min_value: undefined,\n      max_value: undefined,\n      values: [] };\n    var values = bin.values;\n    bin.values = [];\n    bin.max_limit = mid_point;\n    bin.count = 0;\n    bin.max_value = undefined;\n    bin.min_value = undefined;\n    for( var i = 0; i < values.length; ++i ) {\n      if( is_inside_bin( values[i], bin ) ) {\n        add_to_bin( values[i], bin );\n      } else {\n        add_to_bin( values[i], new_bin );\n      }\n    }\n    //log( \"split done, bin: \" + JSON.stringify(bin) + \", new: \" + JSON.stringify(new_bin) );\n    return new_bin;\n  };\n\n\n  function resplit_and_extend(hist) {\n    var alpha = 0.1;\n    var step = 1;\n    \n    new_bins = [];\n    for( var bin_i = 0; bin_i < hist.bins.length; ++bin_i ) {\n      bin = hist.bins[bin_i];\n      if ( ( ( bin.count + 1 ) / ( hist.total + 2 ) ) > alpha && bin.count > 1 ) {\n        new_bin_a = split_bin( bin );\n        new_bins.push( new_bin_a );\n      }\n    }\n    \n    for( var i = 0; i < new_bins.length; ++i ) {\n      hist.bins.push( new_bins[i] );\n    }\n\n    //log( \"resplit: \" + new_bins.length + \" , hist: \" + JSON.stringify(hist) );\n\n    return new_bins.length;\n  };\n\n\n  function add_to_histogram( v, hist ) {\n    for( var i = 0; i < hist.bins.length; ++i ) {\n      if( is_inside_bin( v, hist.bins[i] ) ) {\n        add_to_bin( v, hist.bins[i] );\n        hist.total += 1;\n        return;\n      }\n    }\n    throw \"Unable to add value \" + v + \" to histogram, no bin!\";\n  };\n\n\n  function combine_histograms( hist, other ) {\n    for( var i = 0; i < other.bins.length; ++i ) {\n      for( var j = 0; j < other.bins[i].values.length; ++j ) {\n        add_to_histogram( other.bins[i].values[j], hist );\n      }\n    }\n  };\n\n\n\n  if( !rereduce ) {\n    \n    var hist = {\n      total: 0,\n      bins: [ { min_limit: -100, max_limit: 100,\n                min_value: undefined, max_value: undefined,\n                values: [],\n                count: 0 } ] };\n   \n    for( var i = 0; i < values.length; ++i ) {\n      if( is_inside_bin( values[i], hist.bins[0] ) ) {\n        add_to_bin( values[i], hist.bins[0] );\n        hist.total += 1;\n      } else {\n        throw \"Value outside of largest binning used, values was: \" + values[i];\n      }  \n    }\n\n  } else {\n\n    var hist = values[0];\n    for( var i = 1; i < values.length; ++i ) {\n      combine_histograms( hist, values[i] );\n    }\n  }\n\n  var new_bins = resplit_and_extend( hist );\n  var split_count = 0;\n  while( new_bins > 0 && split_count < 100) {\n    new_bins = resplit_and_extend( hist );\n    split_count += 1;\n  }\n\n  return hist;\n}"
       }
   }
}
